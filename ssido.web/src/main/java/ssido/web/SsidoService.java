// Generated by delombok at Tue Sep 03 11:16:17 CEST 2019
// Copyright (c) 2018, Yubico AB
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
package ssido.web;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.io.Closeables;
import com.upokecenter.cbor.CBORObject;
import ssido.util.CertificateParser;
import ssido.util.ExceptionUtil;
import ssido.util.JacksonCodecs;
import ssido.core.AssertionResult;
import ssido.core.FinishAssertionOptions;
import ssido.core.FinishRegistrationOptions;
import ssido.core.RegisteredCredential;
import ssido.core.RegistrationResult;
import ssido.core.RelyingParty;
import ssido.core.StartAssertionOptions;
import ssido.core.StartRegistrationOptions;
import ssido.core.attestation.Attestation;
import ssido.attestation.AttestationResolver;
import ssido.attestation.MetadataObject;
import ssido.core.attestation.MetadataService;
import ssido.attestation.StandardMetadataService;
import ssido.attestation.TrustResolver;
import ssido.attestation.resolver.CompositeAttestationResolver;
import ssido.attestation.resolver.CompositeTrustResolver;
import ssido.attestation.resolver.SimpleAttestationResolver;
import ssido.web.attestation.resolver.SimpleTrustResolverWithEquality;
import ssido.core.data.AttestationConveyancePreference;
import ssido.core.data.AuthenticatorData;
import ssido.core.data.AuthenticatorSelectionCriteria;
import ssido.core.data.ByteArray;
import ssido.core.data.COSEAlgorithmIdentifier;
import ssido.core.data.PublicKeyCredentialDescriptor;
import ssido.core.data.PublicKeyCredentialCreationOptions;
import ssido.core.data.RelyingPartyIdentity;
import ssido.core.data.UserIdentity;
import ssido.core.data.exception.Base64UrlException;
import ssido.core.exception.AssertionFailedException;
import ssido.core.exception.RegistrationFailedException;
import ssido.core.extension.appid.AppId;
import ssido.core.extension.appid.InvalidAppIdException;
import ssido.data.AssertionRequestWrapper;
import ssido.data.AssertionResponse;
import ssido.data.CredentialRegistration;
import ssido.data.RegistrationRequest;
import ssido.data.RegistrationResponse;
import ssido.data.U2fRegistrationResponse;
import ssido.data.U2fRegistrationResult;
import ssido.web.util.Either;
import java.io.IOException;
import java.io.InputStream;
import java.security.SecureRandom;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.time.Clock;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;
import javax.annotation.Nonnull;
import javax.enterprise.context.ApplicationScoped;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@ApplicationScoped
public class SsidoService {
    private static final Logger LOG = LoggerFactory.getLogger(SsidoService.class);
    
    private static final SecureRandom RANDOM = new SecureRandom();
    private static final String PREVIEW_METADATA_PATH = "/preview-metadata.json";
    private final Cache<ByteArray, AssertionRequestWrapper> assertRequestStorage;
    private final Cache<ByteArray, RegistrationRequest> registerRequestStorage;
    private final RegistrationStorage userStorage;
    private final Cache<AssertionRequestWrapper, AuthenticatedAction> authenticatedActions = newCache();
    private final TrustResolver trustResolver = new CompositeTrustResolver(Arrays.asList(StandardMetadataService.createDefaultTrustResolver(), createExtraTrustResolver()));
    private final MetadataService metadataService = new StandardMetadataService(new CompositeAttestationResolver(Arrays.asList(StandardMetadataService.createDefaultAttestationResolver(trustResolver), createExtraMetadataResolver(trustResolver))));
    private final Clock clock = Clock.systemDefaultZone();
    private final ObjectMapper jsonMapper = JacksonCodecs.json();
    private final RelyingParty rp;

    public SsidoService() throws InvalidAppIdException, CertificateException {
        this(new InMemoryRegistrationStorage(), newCache(), newCache(), WebAuthnConfig.getRpIdentity(), WebAuthnConfig.getOrigins(), WebAuthnConfig.getAppId());
    }

    public SsidoService(RegistrationStorage userStorage, Cache<ByteArray, RegistrationRequest> registerRequestStorage, Cache<ByteArray, AssertionRequestWrapper> assertRequestStorage, RelyingPartyIdentity rpIdentity, Set<String> origins, Optional<AppId> appId) throws InvalidAppIdException, CertificateException {
        this.userStorage = userStorage;
        this.registerRequestStorage = registerRequestStorage;
        this.assertRequestStorage = assertRequestStorage;
        rp = RelyingParty.builder()
                .identity(rpIdentity)
                .credentialRepository(this.userStorage)
                .origins(origins)
                .attestationConveyancePreference(Optional.of(AttestationConveyancePreference.DIRECT))
                .metadataService(Optional.of(metadataService))
                .allowUnrequestedExtensions(true)
                .allowUntrustedAttestation(true)
                .validateSignatureCounter(true)
                .appId(appId)
                .build();
    }

    private static ByteArray generateRandom(int length) {
        byte[] bytes = new byte[length];
        RANDOM.nextBytes(bytes);
        return new ByteArray(bytes);
    }

    private static MetadataObject readPreviewMetadata() {
        InputStream is = SsidoService.class.getResourceAsStream(PREVIEW_METADATA_PATH);
        try {
            return JacksonCodecs.json().readValue(is, MetadataObject.class);
        } catch (IOException e) {
            throw ExceptionUtil.wrapAndLog(LOG, "Failed to read metadata from " + PREVIEW_METADATA_PATH, e);
        } finally {
            Closeables.closeQuietly(is);
        }
    }

    /**
     * Create a {@link TrustResolver} that accepts attestation certificates that are directly recognised as trust anchors.
     */
    private static TrustResolver createExtraTrustResolver() {
        try {
            MetadataObject metadata = readPreviewMetadata();
            return new SimpleTrustResolverWithEquality(metadata.getParsedTrustedCertificates());
        } catch (CertificateException e) {
            throw ExceptionUtil.wrapAndLog(LOG, "Failed to read trusted certificate(s)", e);
        }
    }

    /**
     * Create a {@link AttestationResolver} with additional metadata for unreleased YubiKey Preview devices.
     */
    private static AttestationResolver createExtraMetadataResolver(TrustResolver trustResolver) {
        try {
            MetadataObject metadata = readPreviewMetadata();
            return new SimpleAttestationResolver(Collections.singleton(metadata), trustResolver);
        } catch (CertificateException e) {
            throw ExceptionUtil.wrapAndLog(LOG, "Failed to read trusted certificate(s)", e);
        }
    }

    private static <K, V> Cache<K, V> newCache() {
        return CacheBuilder.newBuilder().maximumSize(100).expireAfterAccess(10, TimeUnit.MINUTES).build();
    }

    public Either<String, RegistrationRequest> startRegistration(
            @Nonnull String username, 
            @Nonnull String displayName, 
            Optional<String> credentialNickname, 
            Optional<ByteArray> requestId, 
            boolean requireResidentKey) {
        LOG.debug("Start registration username: {}, credentialNickname: {}", username, credentialNickname.get());
        if (userStorage.getRegistrationsByUsername(username).isEmpty()) {
                
            UserIdentity userIdentity = UserIdentity.builder()
                    .name(username)
                    .displayName(displayName)
                    .id(generateRandom(32))
                    .build();
            
            AuthenticatorSelectionCriteria authenticatorSelectionCriteria = AuthenticatorSelectionCriteria.builder()
                    .requireResidentKey(requireResidentKey)
                    .build();
            
            StartRegistrationOptions startRegistrationOptions = StartRegistrationOptions.builder()
                            .user(userIdentity)
                            .authenticatorSelection(authenticatorSelectionCriteria)
                            .build();
            
            PublicKeyCredentialCreationOptions publicKeyCredentialCreationOptions = rp.startRegistration(startRegistrationOptions);

            RegistrationRequest request = new RegistrationRequest(
                    username, 
                    credentialNickname, 
                    requestId.isPresent() ? requestId.get() : generateRandom(32), 
                    publicKeyCredentialCreationOptions);
            
            registerRequestStorage.put(request.getRequestId(), request);
            LOG.debug(String.format("Store RegistrationRequest key %s (storage %s", request.getRequestId().getHex(), registerRequestStorage.toString()));
            return Either.right(request);
        } else {
            return Either.left("The username \"" + username + "\" is already registered.");
        }
    }

    public <T> Either<List<String>, AssertionRequestWrapper> startAddCredential(@Nonnull String username, Optional<String> credentialNickname, boolean requireResidentKey, Function<RegistrationRequest, Either<List<String>, T>> whenAuthenticated) {
        LOG.debug("Start AddCredential username: {}, credentialNickname: {}, requireResidentKey: {}", username, credentialNickname, requireResidentKey);
        if (username.isEmpty()) {
            return Either.left(Collections.singletonList("username must not be empty."));
        }
        Collection<CredentialRegistration> registrations = userStorage.getRegistrationsByUsername(username);
        if (registrations.isEmpty()) {
            return Either.left(Collections.singletonList("The username \"" + username + "\" is not registered."));
        } else {
            final UserIdentity existingUser = registrations.stream().findAny().get().getUserIdentity();
            AuthenticatedAction<T> action = (SuccessfulAuthenticationResult result) -> {
                RegistrationRequest request = new RegistrationRequest(username, credentialNickname, generateRandom(32), rp.startRegistration(StartRegistrationOptions.builder().user(existingUser).authenticatorSelection(AuthenticatorSelectionCriteria.builder().requireResidentKey(requireResidentKey).build()).build()));
                registerRequestStorage.put(request.getRequestId(), request);
                return whenAuthenticated.apply(request);
            };
            return startAuthenticatedAction(Optional.of(username), action);
        }
    }

    public static final class SuccessfulRegistrationResult {
        private final boolean success = true;
        private final RegistrationRequest request;
        private final RegistrationResponse response;
        private final CredentialRegistration registration;
        private final boolean attestationTrusted;
        private final Optional<AttestationCertInfo> attestationCert;
        @JsonSerialize(using = AuthDataSerializer.class)
        private final AuthenticatorData authData;

        public SuccessfulRegistrationResult(RegistrationRequest request, RegistrationResponse response, CredentialRegistration registration, boolean attestationTrusted) {
            this.request = request;
            this.response = response;
            this.registration = registration;
            this.attestationTrusted = attestationTrusted;
            attestationCert = Optional.ofNullable(response.getCredential().getResponse().getAttestation().getAttestationStatement().get("x5c")).map(certs -> certs.get(0)).flatMap((JsonNode certDer) -> {
                try {
                    return Optional.of(new ByteArray(certDer.binaryValue()));
                } catch (IOException e) {
                    LOG.error("Failed to get binary value from x5c element: {}", certDer, e);
                    return Optional.empty();
                }
            }).map(AttestationCertInfo::new);
            this.authData = response.getCredential().getResponse().getParsedAuthenticatorData();
        }

        public boolean isSuccess() {
            return this.success;
        }

        public RegistrationRequest getRequest() {
            return this.request;
        }

        public RegistrationResponse getResponse() {
            return this.response;
        }

        public CredentialRegistration getRegistration() {
            return this.registration;
        }

        public boolean isAttestationTrusted() {
            return this.attestationTrusted;
        }

        public Optional<AttestationCertInfo> getAttestationCert() {
            return this.attestationCert;
        }

        public AuthenticatorData getAuthData() {
            return this.authData;
        }
    }


    public final class SuccessfulU2fRegistrationResult {
        private final boolean success = true;
        private final RegistrationRequest request;
        private final U2fRegistrationResponse response;
        private final CredentialRegistration registration;
        private final boolean attestationTrusted;
        private final Optional<AttestationCertInfo> attestationCert;

        public SuccessfulU2fRegistrationResult(final RegistrationRequest request, final U2fRegistrationResponse response, final CredentialRegistration registration, final boolean attestationTrusted, final Optional<AttestationCertInfo> attestationCert) {
            this.request = request;
            this.response = response;
            this.registration = registration;
            this.attestationTrusted = attestationTrusted;
            this.attestationCert = attestationCert;
        }

        public boolean isSuccess() {
            return this.success;
        }

        public RegistrationRequest getRequest() {
            return this.request;
        }

        public U2fRegistrationResponse getResponse() {
            return this.response;
        }

        public CredentialRegistration getRegistration() {
            return this.registration;
        }

        public boolean isAttestationTrusted() {
            return this.attestationTrusted;
        }

        public Optional<AttestationCertInfo> getAttestationCert() {
            return this.attestationCert;
        }
    }

    public static final class AttestationCertInfo {
        private final ByteArray der;
        private final String text;

        public AttestationCertInfo(ByteArray certDer) {
            der = certDer;
            X509Certificate cert = null;
            try {
                cert = CertificateParser.parseDer(certDer.getBytes());
            } catch (CertificateException e) {
                LOG.error("Failed to parse attestation certificate");
            }
            if (cert == null) {
                text = null;
            } else {
                text = cert.toString();
            }
        }

        public ByteArray getDer() {
            return this.der;
        }

        public String getText() {
            return this.text;
        }
    }

    public Either<List<String>, SuccessfulRegistrationResult> finishRegistration(String responseJson) {
        LOG.debug("Finish registration responseJson: {}", responseJson);
        RegistrationResponse response;
        try {
            response = jsonMapper.readValue(responseJson, RegistrationResponse.class);
        } catch (IOException e) {
            LOG.error("JSON error in finishRegistration; responseJson: {}", responseJson, e);
            return Either.left(Arrays.asList("Registration failed!", "Failed to decode response object.", e.getMessage()));
        }
        RegistrationRequest request = registerRequestStorage.getIfPresent(response.getRequestId());
        LOG.debug(String.format("Restore RegistrationRequest key %s storage %s", response.getRequestId().getHex(), registerRequestStorage.toString()));
        registerRequestStorage.invalidate(response.getRequestId());
        
        if (request == null) {
            LOG.debug("Fail finishRegistration responseJson: {}", responseJson);
            return Either.left(Arrays.asList("Registration failed!", "No such registration in progress."));
        } else {
            try {
                RegistrationResult registration = rp.finishRegistration(FinishRegistrationOptions.builder().request(request.getPublicKeyCredentialCreationOptions()).response(response.getCredential()).build());
                return Either.right(new SuccessfulRegistrationResult(request, response, addRegistration(request.getPublicKeyCredentialCreationOptions().getUser(), request.getCredentialNickname(), response, registration), registration.isAttestationTrusted()));
            } catch (RegistrationFailedException e) {
                LOG.debug("Fail finishRegistration responseJson: {}", responseJson, e);
                return Either.left(Arrays.asList("Registration failed!", e.getMessage()));
            } catch (Exception e) {
                LOG.error("fail finishRegistration responseJson: {}", responseJson, e);
                return Either.left(Arrays.asList("Registration failed unexpectedly; this is likely a bug.", e.getMessage()));
            }
        }
    }

    public Either<List<String>, SuccessfulU2fRegistrationResult> finishU2fRegistration(String responseJson) {
        LOG.debug("finishU2fRegistration responseJson: {}", responseJson);
        U2fRegistrationResponse response;
        try {
            response = jsonMapper.readValue(responseJson, U2fRegistrationResponse.class);
        } catch (IOException e) {
            LOG.error("JSON error in finishU2fRegistration; responseJson: {}", responseJson, e);
            return Either.left(Arrays.asList("Registration failed!", "Failed to decode response object.", e.getMessage()));
        }
        RegistrationRequest request = registerRequestStorage.getIfPresent(response.getRequestId());
        registerRequestStorage.invalidate(response.getRequestId());
        if (request == null) {
            LOG.debug("fail finishU2fRegistration responseJson: {}", responseJson);
            return Either.left(Arrays.asList("Registration failed!", "No such registration in progress."));
        } else {
            try {
                ExceptionUtil.assure(U2fVerifier.verify(rp.getAppId().get(), request, response), "Failed to verify signature.");
            } catch (Base64UrlException | IOException | CertificateException e) {
                LOG.debug("Failed to verify U2F signature.", e);
                return Either.left(Arrays.asList("Failed to verify signature.", e.getMessage()));
            }
            X509Certificate attestationCert = null;
            try {
                attestationCert = CertificateParser.parseDer(response.getCredential().getU2fResponse().getAttestationCertAndSignature().getBytes());
            } catch (CertificateException e) {
                LOG.error("Failed to parse attestation certificate: {}", response.getCredential().getU2fResponse().getAttestationCertAndSignature(), e);
            }
            Optional<Attestation> attestation = Optional.empty();
            try {
                if (attestationCert != null) {
                    attestation = Optional.of(metadataService.getAttestation(Collections.singletonList(attestationCert)));
                }
            } catch (CertificateEncodingException e) {
                LOG.error("Failed to resolve attestation", e);
            }
            final U2fRegistrationResult result = U2fRegistrationResult.builder().keyId(PublicKeyCredentialDescriptor.builder().id(response.getCredential().getU2fResponse().getKeyHandle()).build()).attestationTrusted(attestation.map(Attestation::isTrusted).orElse(false)).publicKeyCose(rawEcdaKeyToCose(response.getCredential().getU2fResponse().getPublicKey())).attestationMetadata(attestation).build();
            return Either.right(new SuccessfulU2fRegistrationResult(request, response, addRegistration(request.getPublicKeyCredentialCreationOptions().getUser(), request.getCredentialNickname(), 0, result), result.isAttestationTrusted(), Optional.of(new AttestationCertInfo(response.getCredential().getU2fResponse().getAttestationCertAndSignature()))));
        }
    }

    public Either<List<String>, AssertionRequestWrapper> startAuthentication(Optional<String> username, Optional<ByteArray> requestId) {
        LOG.debug("Start authentication username: {}", username);
        if (username.isPresent() && userStorage.getRegistrationsByUsername(username.get()).isEmpty()) {
            return Either.left(Collections.singletonList("The username \"" + username.get() + "\" is not registered."));
        } else {

            AssertionRequestWrapper request = new AssertionRequestWrapper(
                    requestId.isPresent() ? requestId.get() : generateRandom(32), 
                    rp.startAssertion(StartAssertionOptions.builder().username(username).build()));
            assertRequestStorage.put(request.getRequestId(), request);
            return Either.right(request);
        }
    }


    public static final class SuccessfulAuthenticationResult {
        private final boolean success = true;
        private final AssertionRequestWrapper request;
        private final AssertionResponse response;
        private final Collection<CredentialRegistration> registrations;
        @JsonSerialize(using = AuthDataSerializer.class)
        private final AuthenticatorData authData;
        private final List<String> warnings;

        public SuccessfulAuthenticationResult(AssertionRequestWrapper request, AssertionResponse response, Collection<CredentialRegistration> registrations, List<String> warnings) {
            this(request, response, registrations, response.getCredential().getResponse().getParsedAuthenticatorData(), warnings);
        }

        public boolean isSuccess() {
            return this.success;
        }

        public AssertionRequestWrapper getRequest() {
            return this.request;
        }

        public AssertionResponse getResponse() {
            return this.response;
        }

        public Collection<CredentialRegistration> getRegistrations() {
            return this.registrations;
        }

        public AuthenticatorData getAuthData() {
            return this.authData;
        }

        public List<String> getWarnings() {
            return this.warnings;
        }

        public SuccessfulAuthenticationResult(final AssertionRequestWrapper request, final AssertionResponse response, final Collection<CredentialRegistration> registrations, final AuthenticatorData authData, final List<String> warnings) {
            this.request = request;
            this.response = response;
            this.registrations = registrations;
            this.authData = authData;
            this.warnings = warnings;
        }
    }

    public Either<List<String>, SuccessfulAuthenticationResult> finishAuthentication(String responseJson) {
        LOG.debug("finishAuthentication responseJson: {}", responseJson);
        final AssertionResponse response;
        try {
            response = jsonMapper.readValue(responseJson, AssertionResponse.class);
        } catch (IOException e) {
            LOG.error("Failed to decode response object", e);
            return Either.left(Arrays.asList("Assertion failed!", "Failed to decode response object.", e.getMessage()));
        }
        AssertionRequestWrapper request = assertRequestStorage.getIfPresent(response.getRequestId());
        assertRequestStorage.invalidate(response.getRequestId());
        if (request == null) {
            return Either.left(Arrays.asList("Assertion failed!", "No such assertion in progress."));
        } else {
            try {
                AssertionResult result = rp.finishAssertion(FinishAssertionOptions.builder().request(request.getRequest()).response(response.getCredential()).build());
                if (result.isSuccess()) {
                    try {
                        userStorage.updateSignatureCount(result);
                    } catch (Exception e) {
                        LOG.error("Failed to update signature count for user \"{}\", credential \"{}\"", result.getUsername(), response.getCredential().getId(), e);
                    }
                    return Either.right(new SuccessfulAuthenticationResult(request, response, userStorage.getRegistrationsByUsername(result.getUsername()), result.getWarnings()));
                } else {
                    return Either.left(Collections.singletonList("Assertion failed: Invalid assertion."));
                }
            } catch (AssertionFailedException e) {
                LOG.error("Assertion failed", e);
                return Either.left(Arrays.asList("Assertion failed!", e.getMessage()));
            } catch (Exception e) {
                LOG.error("Assertion failed", e);
                return Either.left(Arrays.asList("Assertion failed unexpectedly; this is likely a bug.", e.getMessage()));
            }
        }
    }

    public Either<List<String>, AssertionRequestWrapper> startAuthenticatedAction(Optional<String> username, AuthenticatedAction<?> action) {
        return startAuthentication(username, Optional.empty()).map(request -> {
            synchronized (authenticatedActions) {
                authenticatedActions.put(request, action);
            }
            return request;
        });
    }

    public Either<List<String>, ?> finishAuthenticatedAction(String responseJson) {
        return finishAuthentication(responseJson).flatMap(result -> {
            AuthenticatedAction<?> action = authenticatedActions.getIfPresent(result.request);
            authenticatedActions.invalidate(result.request);
            if (action == null) {
                return Either.left(Collections.singletonList("No action was associated with assertion request ID: " + result.getRequest().getRequestId()));
            } else {
                return action.apply(result);
            }
        });
    }

    public <T> Either<List<String>, AssertionRequestWrapper> deregisterCredential(String username, ByteArray credentialId, Function<CredentialRegistration, T> resultMapper) {
        LOG.debug("Deregister credential username: {}, credentialId: {}", username, credentialId);
        if (username == null || username.isEmpty()) {
            return Either.left(Collections.singletonList("Username must not be empty."));
        }
        if (credentialId == null || credentialId.getBytes().length == 0) {
            return Either.left(Collections.singletonList("Credential ID must not be empty."));
        }
        AuthenticatedAction<T> action = (SuccessfulAuthenticationResult result) -> {
            Optional<CredentialRegistration> credReg = userStorage.getRegistrationByUsernameAndCredentialId(username, credentialId);
            if (credReg.isPresent()) {
                userStorage.removeRegistrationByUsername(username, credReg.get());
                return Either.right(resultMapper.apply(credReg.get()));
            } else {
                return Either.left(Collections.singletonList("Credential ID not registered:" + credentialId));
            }
        };
        return startAuthenticatedAction(Optional.of(username), action);
    }

    public <T> Either<List<String>, T> deleteAccount(String username, Supplier<T> onSuccess) {
        LOG.debug("Delete account username: {}", username);
        if (username == null || username.isEmpty()) {
            return Either.left(Collections.singletonList("Username must not be empty."));
        }
        boolean removed = userStorage.removeAllRegistrations(username);
        if (removed) {
            return Either.right(onSuccess.get());
        } else {
            return Either.left(Collections.singletonList("Username not registered:" + username));
        }
    }

    private CredentialRegistration addRegistration(UserIdentity userIdentity, Optional<String> nickname, RegistrationResponse response, RegistrationResult result) {
        return addRegistration(userIdentity, 
                nickname, 
                response.getCredential().getResponse().getAttestation().getAuthenticatorData().getSignatureCounter(), 
                RegisteredCredential.builder()
                        .credentialId(result.getKeyId().getId())
                        .userHandle(userIdentity.getId())
                        .publicKeyCose(result.getPublicKeyCose())
                        .signatureCount(response.getCredential().getResponse().getParsedAuthenticatorData().getSignatureCounter()).build(), 
                result.getAttestationMetadata());
    }

    private CredentialRegistration addRegistration(UserIdentity userIdentity, Optional<String> nickname, long signatureCount, U2fRegistrationResult result) {
        return addRegistration(userIdentity, nickname, signatureCount, RegisteredCredential.builder().credentialId(result.getKeyId().getId()).userHandle(userIdentity.getId()).publicKeyCose(result.getPublicKeyCose()).signatureCount(signatureCount).build(), result.getAttestationMetadata());
    }

    private CredentialRegistration addRegistration(UserIdentity userIdentity, Optional<String> nickname, long signatureCount, RegisteredCredential credential, Optional<Attestation> attestationMetadata) {
        CredentialRegistration reg = CredentialRegistration.builder().userIdentity(userIdentity).credentialNickname(nickname).registrationTime(clock.instant()).credential(credential).signatureCount(signatureCount).attestationMetadata(attestationMetadata).build();
        LOG.debug("Adding registration: user: {}, nickname: {}, credential: {}", userIdentity, nickname, credential);
        userStorage.addRegistrationByUsername(userIdentity.getName(), reg);
        return reg;
    }

    static ByteArray rawEcdaKeyToCose(ByteArray key) {
        final byte[] keyBytes = key.getBytes();
        if (!(keyBytes.length == 64 || (keyBytes.length == 65 && keyBytes[0] == 4))) {
            throw new IllegalArgumentException(String.format("Raw key must be 64 bytes long or be 65 bytes long and start with 0x04, was %d bytes starting with %02x", keyBytes.length, keyBytes[0]));
        }
        final int start = keyBytes.length == 64 ? 0 : 1;
        Map<Long, Object> coseKey = new HashMap<>();
        coseKey.put(1L, 2L); // Key type: EC
        coseKey.put(3L, COSEAlgorithmIdentifier.ES256.getId());
        coseKey.put(-1L, 1L); // Curve: P-256
        coseKey.put(-2L, Arrays.copyOfRange(keyBytes, start, start + 32)); // x
        coseKey.put(-3L, Arrays.copyOfRange(keyBytes, start + 32, start + 64)); // y
        return new ByteArray(CBORObject.FromObject(coseKey).EncodeToBytes());
    }


    private static class AuthDataSerializer extends JsonSerializer<AuthenticatorData> {
        @Override
        public void serialize(AuthenticatorData value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeStartObject();
            gen.writeStringField("rpIdHash", value.getRpIdHash().getHex());
            gen.writeObjectField("flags", value.getFlags());
            gen.writeNumberField("signatureCounter", value.getSignatureCounter());
            value.getAttestedCredentialData().ifPresent(acd -> {
                try {
                    gen.writeObjectFieldStart("attestedCredentialData");
                    gen.writeStringField("aaguid", acd.getAaguid().getHex());
                    gen.writeStringField("credentialId", acd.getCredentialId().getHex());
                    gen.writeStringField("publicKey", acd.getCredentialPublicKey().getHex());
                    gen.writeEndObject();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
            gen.writeObjectField("extensions", value.getExtensions());
            gen.writeEndObject();
        }
    }
}
